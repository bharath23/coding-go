package leetcod0046

/*
This is a recursive solution where permutations are generated by
progressively appending elements. Building each permutation takes O(n) time.
Since there are n! possible permutations, the total time complexity is
O(n × n!).

To store the permutations in a result array, we need O(n) space per
permutation. For n! permutations, this results in O(n × n!) space.
Additionally, the recursion stack has a depth of O(n). Therefore, the total
space complexity is O(n × n!) + O(n), which simplifies to O(n × n!).

Time complexity: O(n.n!)
Space complexity: O(n.n!)
*/
func permutev0(nums []int) [][]int {
	if len(nums) == 0 {
		return [][]int{}
	}

	if len(nums) == 1 {
		return [][]int{nums}
	}

	result := [][]int{}
	for i, n := range nums {
		rest := append([]int{}, nums[:i]...)
		rest = append(rest, nums[i+1:]...)
		restPermutation := permutev0(rest)
		for _, p := range restPermutation {
			perm := append([]int{n}, p...)
			result = append(result, perm)
		}
	}

	return result
}

/*
This is a backtracking solution where permutations are generated by
recursively swapping elements. Constructing each permutation takes O(n) time,
and since there are n! permutations, the total time complexity is O(n × n!).

To store the permutations in a result array, we need O(n) space per
permutation. For n! permutations, this results in O(n × n!) space.
Additionally, the recursion stack used during backtracking has a depth of
O(n). Therefore, the total space complexity is O(n × n!) + O(n), which
simplifies to O(n × n!).

Time complexity: O(n.n!)
Space complexity: O(n.n!)
*/
func permutev1(nums []int) [][]int {
	result := [][]int{}
	var backtrack func(int)
	backtrack = func(first int) {
		if first == len(nums) {
			tmp := make([]int, len(nums))
			copy(tmp, nums)
			result = append(result, tmp)
			return
		}

		for i := first; i < len(nums); i++ {
			nums[first], nums[i] = nums[i], nums[first]
			backtrack(first + 1)
			nums[first], nums[i] = nums[i], nums[first]
		}
	}

	backtrack(0)
	return result
}
